from eom import load_equations_of_motions
import os

def generate_dynamics_script(n_poles: int, sols):
    eqs_str = [str(sol) for sol in sols]
    replace = {
        "sin": "jnp.sin",
        "cos": "jnp.cos",
    }
    for old, new in replace.items():
        eqs_str = [eq_str.replace(old, new) for eq_str in eqs_str]
    script = "import jax\n"
    script += "import jax.numpy as jnp\n"
    script += "from typing import Sequence, Callable\n"
    script += "\n# This file and its content are generated by generate_dynamics.py\n"
    script += f"\ndef generate_dynamics_with_{n_poles}_poles(mc: float, g: float, phi: float, pole_ms: Sequence[float], pole_ls: Sequence[float], pole_as: Sequence[float], pole_ds: Sequence[float], pole_Js: Sequence[float]) -> tuple[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray], Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray], Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]:\n"
    states = "\t\ts, ds"
    states_ = "\t\ts_, ds_"
    ddthetas = ""
    params = ""
    dstates = f"\t\tdstate = jnp.array([ds, dds"
    observation = f"\t\tobservation = jnp.array([s, ds"

    for i in range(n_poles):
        states += f", theta{i+1}, dtheta{i+1}"
        states_ += f", theta{i+1}_, dtheta{i+1}_"
        ddthetas += f"\t\tddtheta{i+1} = {eqs_str[i+1]}\n"
        params += f"\tm{i+1}, l{i+1}, a{i+1}, d{i+1}, J{i+1} = pole_ms[{i}], pole_ls[{i}], pole_as[{i}], pole_ds[{i}], pole_Js[{i}]\n"
        dstates += f", dtheta{i+1}, ddtheta{i+1}"
        observation += f", theta{i+1}, dtheta{i+1}"
    script += params
    script += "\n\t@jax.jit\n"
    script += "\tdef dynamics_function(state: jnp.ndarray, action: jnp.ndarray) -> jnp.ndarray:\n"
    script += states + " = state\n"
    script += "\t\tdds = action[0]\n"
    script += ddthetas
    script += f"{dstates}])\n"
    script += "\t\treturn dstate\n"

    script += "\n\t@jax.jit\n"
    script += "\tdef observation_function(state: jnp.ndarray, action: jnp.ndarray) -> jnp.ndarray:\n"
    script += states + " = state\n"
    script += "\t\tdds = action[0]\n"
    script += f"\t\ttau = {eqs_str[0]}\n"
    script += f"{observation}, tau])\n"
    script += "\t\treturn observation\n"

    script += "\n\t@jax.jit\n"
    script += "\tdef distance_function(state: jnp.ndarray, goal_state: jnp.ndarray) -> jnp.ndarray:\n"
    script += states + " = state\n"
    script += states_ + " = goal_state\n"
    dist = f"\t\tdist = jnp.array([dist_s, dist_ds"
    script += "\t\tdist_s = s_-s\n"
    script += "\t\tdist_ds = ds_-ds\n"
    for i in range(n_poles):
        script += f"\t\tdist_theta{i+1} = jnp.arctan2(jnp.sin(theta{i+1}-theta{i+1}_), jnp.cos(theta{i+1}-theta{i+1}_))\n"
        script += f"\t\tdist_dtheta{i+1} = dtheta{i+1}_-dtheta{i+1}\n"
        dist += f", dist_theta{i+1}, dist_dtheta{i+1}"
    script += f"{dist}])\n"
    script += "\t\treturn dist\n"
    script += f"\n\treturn dynamics_function, observation_function, distance_function\n"

    # save to a script
    current_path = os.path.dirname(__file__)
    final_path = f"{current_path}/dynamics/dynamics_with_{n_poles}_poles.py"
    with open(final_path, "w") as f:
        f.write(script)

def generate_eom() -> None:
    max_n_poles = 2

    for n_poles in range(1, max_n_poles+1):
        print(f"Loading equations of motion for {n_poles} poles...")
        pure_sols = load_equations_of_motions(n_poles)

        print("Generating dynamics scripts...")
        generate_dynamics_script(n_poles, pure_sols)

if __name__ == "__main__":
    generate_eom()