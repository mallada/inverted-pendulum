import jax
import jax.numpy as jnp
from typing import Sequence, Callable

# This file and its content are generated by generate_dynamics.py

def generate_dynamics_with_1_poles(mc: float, g: float, phi: float, pole_ms: Sequence[float], pole_ls: Sequence[float], pole_as: Sequence[float], pole_ds: Sequence[float], pole_Js: Sequence[float]) -> tuple[Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray], Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray], Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]]:
	m1, l1, a1, d1, J1 = pole_ms[0], pole_ls[0], pole_as[0], pole_ds[0], pole_Js[0]

	@jax.jit
	def dynamics_function(state: jnp.ndarray, action: jnp.ndarray) -> jnp.ndarray:
		s, ds, theta1, dtheta1 = state
		dds = action[0]
		ddtheta1 = (-a1*dds*m1*jnp.cos(theta1) - a1*g*m1*jnp.sin(phi - theta1) - d1*dtheta1)/(J1 + a1**2*m1)
		dstate = jnp.array([ds, dds, dtheta1, ddtheta1])
		return dstate

	@jax.jit
	def observation_function(state: jnp.ndarray, action: jnp.ndarray) -> jnp.ndarray:
		s, ds, theta1, dtheta1 = state
		dds = action[0]
		tau = (-J1*a1*dtheta1**2*m1*jnp.sin(theta1) + J1*dds*m1 + J1*dds*mc + J1*g*m1*jnp.sin(phi) - a1**3*dtheta1**2*m1**2*jnp.sin(theta1) + a1**2*dds*m1**2*jnp.sin(theta1)**2 + a1**2*dds*m1*mc + a1**2*g*m1**2*jnp.sin(phi) - a1**2*g*m1**2*jnp.sin(phi - theta1)*jnp.cos(theta1) - a1*d1*dtheta1*m1*jnp.cos(theta1))/(J1 + a1**2*m1)
		observation = jnp.array([s, ds, theta1, dtheta1, tau])
		return observation

	@jax.jit
	def distance_function(state: jnp.ndarray, goal_state: jnp.ndarray) -> jnp.ndarray:
		s, ds, theta1, dtheta1 = state
		s_, ds_, theta1_, dtheta1_ = goal_state
		dist_s = s_-s
		dist_ds = ds_-ds
		dist_theta1 = jnp.arctan2(jnp.sin(theta1-theta1_), jnp.cos(theta1-theta1_))
		dist_dtheta1 = dtheta1_-dtheta1
		dist = jnp.array([dist_s, dist_ds, dist_theta1, dist_dtheta1])
		return dist

	return dynamics_function, observation_function, distance_function
